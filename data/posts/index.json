[
  {
    "title": "[Day27] Read Rust Atomics and Locks - Common Misconceptions in memory ordering",
    "createdDate": "2023-08-03",
    "categories": [
      "cs"
    ],
    "file": "day27-read-rust-atomics-and-locks-common-misconceptions-in-memory-ordering_230803",
    "excerpt": "Memory ordering is about things like reordering instructions, which usually happen at nanosecond scale no matter which ordering is used."
  },
  {
    "title": "[Day26] Read Rust Atomics and Locks - Fences",
    "createdDate": "2023-08-01",
    "categories": [
      "cs"
    ],
    "file": "day26-read-rust-atomics-and-locks-fences_230801",
    "excerpt": "In addition to memory operations on atomic variables, memory ordering can also be applied to atomic fences in concurrent programming"
  },
  {
    "title": "[Day25] Read Rust Atomics and Locks - Sequentially Consistent Ordering",
    "createdDate": "2023-07-19",
    "categories": [
      "cs"
    ],
    "file": "day25-read-rust-atomics-and-locks-sequentially-consistent-ordering_230719",
    "excerpt": "Each operation using SeqCst memory ordering contributes to a global order in which all operations are arranged"
  },
  {
    "title": "[Day24] Read Rust Atomics and Locks - Consume Ordering",
    "createdDate": "2023-07-18",
    "categories": [
      "cs"
    ],
    "file": "day24-read-rust-atomics-and-locks-consume-ordering_230718",
    "excerpt": "no compiler actually implements consume ordering"
  },
  {
    "title": "[Day23] Read Rust Atomics and Locks - Release and Acquire Ordering",
    "createdDate": "2023-07-14",
    "categories": [
      "cs"
    ],
    "file": "day23-read-rust-atomics-and-locks-release-and-acquire-ordering_230714",
    "excerpt": "Target: to form a happens-before relationship between threads"
  },
  {
    "title": "[Day22] Read Rust Atomics and Locks - Relaxed Ordering",
    "createdDate": "2023-07-07",
    "categories": [
      "cs"
    ],
    "file": "day22-read-rust-atomics-and-locks-relaxed-ordering_230707",
    "excerpt": "Atomic operations using relaxed memory ordering promises from the perspective of every other threads all modifications of the same atomic variable happen in a same order"
  },
  {
    "title": "[Day21] Read Rust Atomics and Locks - Happens-Before Relationship",
    "createdDate": "2023-07-04",
    "editedDate":"2023-07-05",
    "categories": [
      "cs"
    ],
    "file": "day21-read-rust-atomics-and-locks-happens-before-relationship_230704",
    "excerpt": "one thing is guaranteed to happen before another thing"
  },
  {
    "title": "[Day20] Read Rust Atomics and Locks - The Memory Model",
    "createdDate": "2023-06-30",
    "editedDate":"2023-07-12",
    "categories": [
      "cs"
    ],
    "file": "day20-read-rust-atomics-and-locks-the-memory-model_230630"
  },
  {
    "title": "[Day19] Read Rust Atomics and Locks - Memory Reordering and Optimizations",
    "createdDate": "2023-06-29",
    "categories": [
      "cs"
    ],
    "file": "day19-read-rust-atomics-and-locks-memory-reordering-and-optimizations_230629",
    "excerpt": "Processors and compilers perform all sorts of tricks to make your programs run as fast as possible"
  },
  {
    "title": "[Day18] Read Rust Atomics and Locks - Atomic Compare-and-Exchange Operations",
    "createdDate": "2023-06-27",
    "editedDate":"2023-07-14",
    "categories": [
      "cs"
    ],
    "file": "day18-read-rust-atomics-and-locks-atomic-compare-and-exchange-oprations_230627",
    "excerpt": "Compare-and-Exchange checks if the atomic value is equal to a given value, and only if that is the case does it replace it with a new value"
  },
  {
    "title": "[Day17] Read Rust Atomics and Locks - Atomic Fetch-and-Modify Operations",
    "createdDate": "2023-06-19",
    "editedDate":"2023-06-27",
    "categories": [
      "cs"
    ],
    "file": "day17-read-rust-atomics-and-locks-atomic-fetch-and-modify-oprations_230619",
    "excerpt": "These operations modify the atomic variable, but also load (fetch) the original value, as a single atomic operation."
  },
  {
    "title": "[Day16] Read Rust Atomics and Locks - Atomic Load and Store Operations",
    "createdDate": "2023-06-07",
    "editedDate":"2023-07-14",
    "categories": [
      "cs"
    ],
    "file": "day16-read-rust-atomics-and-locks-atomic-load-and-store-oprations_230608",
    "excerpt": "Some common use cases: a stop flag, process reporting"
  },
  {
    "title": "[Day15] Read Rust Atomics and Locks - Intro of Atmoics",
    "createdDate": "2023-06-06",
    "categories": [
      "cs"
    ],
    "file": "day15-read-rust-atomics-and-locks-introOf-atomics_230606",
    "excerpt": "Atomic operations allow for different threads to safely read and modify the same variable"
  },
  {
    "title": "[Day14] Read Rust Atomics and Locks - Thread Parking and condition variables",
    "createdDate": "2023-06-04",
    "categories": [
      "cs"
    ],
    "file": "day14-read-rust-atomics-and-locks-thread-parking-condition-variables_230604",
    "excerpt": "When data is mutated by multiple threads, there are many situations where they would need to wait for some event, for some condition about the data to become true."
  },
  {
    "title": "[Day13] Read Rust Atomics and Locks - More about Reader-Writer Lock",
    "createdDate": "2023-06-02",
    "editedDate": "2023-06-03",
    "categories": [
      "cs"
    ],
    "file": "day13-read-rust-atomics-and-locks-more-about-rwlock_230602",
    "excerpt": "A reader-writer understands the difference between exclusive and shared access, and can provide either."
  },
  {
    "title": "[Day12] Read Rust Atomics and Locks - Lock Poisoning",
    "createdDate": "2023-05-31",
    "categories": [
      "cs"
    ],
    "file": "day12-read-rust-atomics-and-locks-lock-poisoning_230531",
    "excerpt": "A Mutex in Rust gets marked as poisoned when a thread panics while holding the lock."
  },
  {
    "title": "[Day11] Read Rust Atomics and Locks - Rust's Mutex",
    "createdDate": "2023-05-29",
    "categories": [
      "cs"
    ],
    "file": "day11-read-rust-atomics-and-locks-rusts-mutex_230529",
    "excerpt": "While using a mutex can ensure serialized execution, it also negates the advantages of parallelism"
  },
  {
    "title": "[Day10] Read Rust Atomics and Locks - Trait Send and Sync",
    "createdDate": "2023-05-28",
    "categories": [
      "cs"
    ],
    "file": "day10-read-rust-atomics-and-locks-trait-send-sync_230528",
    "excerpt": "Rust uses trait `Send` and `Sync` to keep track of which types can be safely used across threads. With them, the compiler can check for you, so you can use these types without having to use `unsafe` blocks."
  },
  {
    "title": "[Day9] Read Rust Atomics and Locks - Mutex, RwLock, Atomics and UnsafeCell",
    "createdDate": "2023-05-25",
    "categories": [
      "cs"
    ],
    "file": "day9-read-rust-atomics-and-locks-mutex-rwLock-atomics-unsafeCell_230525",
    "excerpt": "A `Mutex` is very similar to `RwLock`, but it only allows exclusive borrows"
  },
  {
    "title": "[Day8] Read Rust Atomics and Locks - Cell, RefCell",
    "createdDate": "2023-05-24",
    "categories": [
      "cs"
    ],
    "file": "day8-read-rust-atomics-and-locks-cell-refcell_230524",
    "excerpt": "`std::cell::Cell<T>`, `std::cell::RefCell`"
  },
  {
    "title": "[Day7] Read Rust Atomics and Locks - Interior Mutability",
    "createdDate": "2023-05-22",
    "categories": [
      "cs"
    ],
    "file": "day7-read-rust-atomics-and-locks-interior-mutability_230522",
    "excerpt": "Interior mutability only bends the rules of shared borrowing to allow mutation when shared"
  },
  {
    "title": "[沒遇過就不會之一] 避免資料庫的重複貨幣帳戶",
    "createdDate": "2023-05-21",
    "editedDate": "2023-05-26",
    "categories": [
      "cs"
    ],
    "file": "no-experience-no-knowledge_1-avoiding-duplicate-currency-accounts-in-a-database_230521",
    "excerpt": "在具有多帳戶功能的系統中，一個 User 可以有多個 Account ，而在 Account table 中又可以儲存多種幣別 (USD, NTD…) 。我們可以利用 `composite index` 加上 `unique` 的特性， 令 User 避免持有相同的幣別的 Account"
  },
  {
    "title": "[Day6] Read Rust Atomics and Locks",
    "createdDate": "2023-05-17",
    "categories": [
      "cs"
    ],
    "file": "day6-read-rust-atomics-and-locks_230517",
    "excerpt": "Immutable borrowing(&) + Mutable borrowing(&mut) = fully prevent data races"
  },
  {
    "title": "[Day5] Read Rust Atomics and Locks",
    "createdDate": "2023-05-11",
    "categories": [
      "cs"
    ],
    "file": "day5-read-rust-atomics-and-locks_230511",
    "excerpt": "Some ways to share ownership to threads: `static`, `Box::leak(Box::new([1, 2, 3]));`, `Arc`"
  },
  {
    "title": "[Day4] Read Rust Atomics and Locks",
    "createdDate": "2023-05-08",
    "categories": [
      "cs"
    ],
    "file": "day4-read-rust-atomics-and-locks_230508",
    "excerpt": "std::thread::scope spawn scoped threads => possible to safely borrow local variables. eg:"
  },
  {
    "title": "[Golang] Golang 的 Set",
    "createdDate": "2023-05-04",
    "categories": [
      "cs"
    ],
    "file": "golang-set-in-golang_230504",
    "excerpt": "某天在使用 Golang 的時候，突然發現原來 Golang 沒有像其他語言一樣有實作 Set 的 data structure，稍微爬了文後發現，原來 Golang 會用 map 來模擬 Set ，以下是僅是小小的紀錄。"
  },
  {
    "title": "[Day3] Read Rust Atomics and Locks",
    "createdDate": "2023-04-17",
    "categories": [
      "cs"
    ],
    "file": "day3-read-rust-atomics-and-locks_230409",
    "excerpt": "The `std::thread::spawn` function is actually just a convenient shorthand for `std::thread::Builder::new().spawn().unwrap()"
  },
  {
    "title": "[Golang] Polymorphism in Golang",
    "createdDate": "2023-04-06",
    "editedDate": "2023-05-08",
    "categories": [
      "cs"
    ],
    "file": "golang-polymorphism-in-golang_230508",
    "excerpt": "Polymorphism 的目的？ 藉由 Polymorphism 使 code 更加靈活、reusable、易擴展和可維護"
  },
  {
    "title": "[Day2] Read Rust Atomics and Locks",
    "createdDate": "2023-03-04",
    "categories": [
      "cs"
    ],
    "file": "day2-read-rust-atomics-and-locks_230304",
    "excerpt": "A process should always ask OS kernel first and then interact with another process in Rust, to spawn a new thread"
  },
  {
    "title": "[JavaScript] 我對 Object key 的錯誤認知",
    "createdDate": "2022-09-17",
    "categories": [
      "cs",
      "web"
    ],
    "file": "javascript-my-misunderstanding-about-object-key_220917",
    "excerpt": "我原本一直以為假若使用 Array 或者 Object 當作另一個 Object 的 key 時，會使用他們的 reference, 直到我遇到了 bug 並且簡單做了測試"
  }
]
